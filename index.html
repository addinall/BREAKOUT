<!DOCTYPE html>
<html>
   <head>
   <meta http-equiv="content-type" content= "text/html; charset=UTF-8">
<!--  vim: set tabstop=4 shiftwidth=4 expandtab autoindent smartindent :


        index.html
        Mark Addinall
        July 2013
        Experimentation with the HTML5 canvas and audio objects
        This one is the breakout game revisited in HTML5/CSS3 and Javascript.
        SHOULD be cross platform and responsive (to an extent.  Game canvas
        really doesn't re-size well.).

        I was doing this on-line course
            https://www.udacity.com/course/viewer#!/c-cs255/l-49464373/e-73862325/m-86304040
        Dont bother, it sucks.  THEY make mistakes on EVERY example in the tutition.
        So I went searching GOOGLE for bits and bobs to learn some game programming
        and came up with this.
        
        This does a whole bunch of things differently  than the first
        cuts from bits and bobs from the net. I was interested in game
        programming techniques to discover that the people who were
        publishing "HOW TO" game coding had very poor overall programming skills.

        So I took what I could from the world of game design, and applied
        some more traditional techniques and structure to the overall
        development.  Still a great learning experience for me.  I am loving
        HTML5 and CSS3.


        Has toggling features, HTML5 local.storage and a deal of CSS3 control.
        This validates HTML5 and CSS3.
        I wrote most of in-line concept code into a modular design.

        Start and stopping controls are now available.
        Finished the board being randomly generated with a half decent
        weighting algorithm.  The localStorage of high scores is finished,
        although this is going to be modified when I do more work on
        'levels'.

        TODO:
        Play around with the graphics capabilities of the canvas element
        to try and get the graphics looking a little slicker.   
        Take it all out of one file and stick it in a standard
        html->name-> css sfx js directory structure.

-->
    <title>BREAKOUT! - HTML5 experiments</title>

    <meta name="author" content="Mark Addinall Brisbane Australia">
    <meta name="keywords" content="HTML5, CSS3, Javascript, cross platform">
    <meta name="description" content="This is an implementation of the BREAKOUT game using HTML5, CSS3 and Javascript">

    <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.4.2/jquery.min.js"></script>

    <script>



$(document).ready(function(){

            var canvas = document.getElementById('myCanvas');

            // jQuery has shorthand for that, = $('#myCanvas')[0];
            // but until I REALLY want the quick and dirty shorthand,
            // we will do it the long hand way for clarity.
            // at the moment I am only using jQuery twice.  I might
            // dump it for this project just to save a little space
            // on the mobile devices.

            var unit_test = false;                                      // switch between test mode


            // -------------- Graphics section ---------------------
            // OK.  We bring the gradient graphical calculations
            // up a level and make them global to this namespace.
            // the scope is not an issue (although we could re-use
            // the schemes in future expabnsions, but the computational
            // overhead IS an issue.  I have noticed in the general
            // 'HOW TO' games world, that these things seem to be
            // re-computed over and over and over.  Some thousands of times
            // in some instances.  I am bringing this lot up here
            // so that the calculations can be done ONCE, on page load,
            // and never, ever again.


            var context = canvas.getContext('2d');                      // this is a crap naming convention
                                                                        // and should really be changed
                                                                        // before <canvas> gets any more
                                                                        // complicated.


            // gradient for the End Game Banner texts

            var end_gradient = context.createLinearGradient(5, 50, 500, 20);

            end_gradient.addColorStop(0.1,  '#F82E23');
            end_gradient.addColorStop(0.25, '#E2E651');
            end_gradient.addColorStop(0.5,  '#55D268');
            end_gradient.addColorStop(0.75, '#5A77DA');
            end_gradient.addColorStop(1,    '#C84489');

            // brick gradients


            var yellow_gradient = context.createLinearGradient(5, 50, 500, 20);
            

            // ------------ audio section ----------------
            // get the sound effects from the markup below
            // both WAV and MP3 versions of SFX are presented
            // to the HTML5 markup.  This will enable sounds
            // to be consistant over all of the major
            // browsers.

            var noise_on    = true;                                     // sound toggle
            
            var bounce      = document.getElementById('bounce');        // ball hits ANYTHING
            var explode     = document.getElementById('explode');       // brick is destroyed
            var over        = document.getElementById('over');          // game over gurgle
            var firework    = document.getElementById('firework');      // player won!  YAH!
            var missed      = document.getElementById('missed');        // ball fell down the back

            firework.volume = 1;                                        // couple of quiet SFX
            missed.volume   = 1;                                        // the range of volume is 0 .. 1
                                                                        // that was hard to find
            over.volume     = 1; 
            bounce.volume   = 0.2;                                      // the sample volume range of 
            explode.volume  = 0.4;                                      // the SFX i got off the net
                                                                        // varied a GREAT deal so some
                                                                        // volume munging became needed.
                                                                        // either the BOING would give you
                                                                        // a migrane and the EXPLOSION
                                                                        // made the missus drop a glass
                                                                        // of plonk, or you couldn't
                                                                        // hear the applause!!!



            // --------------  general game globals section ----------

            var bonus_time          = 900;                              // 15 minutes
            var lives               = 3                                 // 3 misses, then death
            var won                 = false;                            // assume failure (NBN)
            var level               = 1;                                // current game elevel (can save)

            var score               = 0;                                // 1 for hit, 10 for boom, modified
            var scores              = [];                               // top 10 list for local storage
            var high_scores         =   "";                             // JSON stringified scores


            var tickTimer;                                              // these two are up here because of
            var gameLoop;                                               // a scope issue.  The internal timer
                                                                        // was not being reset correctly on
                                                                        // partial (software driven) game
                                                                        // restarts.

            var ticks               = 0;                                // by the time it takes to complete

            var paddle_x;                                               // arbitary place to stick the paddle
            var paddle_y;

            // now some variable for the paddle

            var paddle_width;                                           // there is a bug in these
            var paddle_height;                                          // numbers somewhere.  sometimes
            var paddle_size;                                            // the ball can rest on the underside
                                                                        // of the paddle for a moment????
            var paddle_deltax;                                          // pixel offsets when moving
            var paddle_deltay;                                          // the paddle

            var paddle_move;                                            // start still
            var paddle_speedx;                                          // number of pixels to move per
                                                                        // game cycle
            // now variables for the ball

            var ball_x;                                                 // arbitary place to stick the ball
            var ball_y;

            var ball_deltax;                                            // pixel offsets when moving
            var ball_deltay;                                            // modified by collisions

            var ball_size;                                              // RADIUS in pixels
            var ball_speed;                                             // speed multiplier

            // now for the bricks.  starting out pretty plain
            // looking, but when the game engine is working
            // we will tart them up.


            var bricks = [];                                            // empty to start.  This array
                                                                        // is filled from two locations,
                                                                        // initial play and play again

            var bricks_per_row      = 10;                               // magic numbers.  might change
            var rows_of_bricks      = 6;                                // magic number WILL change
            var brick_height        = 22;                               // based on difficulty level or
            var brick_width         = canvas.width/bricks_per_row;      // device type

       

            // end PROPERTIES ------ BEGIN METHODS ---------------------


            //---------------------
            function get_scores() {


                if (window.localStorage) {
                    high_scores = localStorage.getItem("break-highscores");
                }

                if (high_scores != null ) {                 // this test is REALLY important
                    scores = JSON.parse(high_scores);       // doing ANYTHING to a null just spins
                }                                           // the machine forever!
                
                scores = scores.filter(function(n){return n})
                                                            // just in case we have an array full
                                                            // of nulls.  this is something else
                                                            // that REALLY upsets javascript!!!
                if (scores.length == 0) {
                    scores.push(["Angry Anderson", 666, 1]);// don't return a null array
                }                                           // javascript throws a fit in the new local
            }                                               // storage routines on bad data

            //---------------------
            function put_scores() {

                localStorage.setItem("break-highscores", high_scores);

            }

            //------------------------
            function delete_scores() {

                localStorage.removeItem("break-highscores");
            }


            //-----------------------
            function sort_scores() {

                scores.sort( function( a, b ) {

                    // Sort by the 2nd value in each array, which is, the score!

                    if ( a[1] == b[1] ) return 0;
                    return b[1] - a[1];
                });

                if (scores.length > 9) {
                    scores.length = 9;                  // we just chop this to make the Leader Board look neat.
                }
            }


            //---------------------------
            function stringify_scores() {

               high_scores = JSON.stringify(scores);    // take a multi-dimensional array and turn it into
                                                        // a string representation of a JSON object.
            }



            //----------------------
            function toggleNoise() {

                noise_on = !noise_on;                   // just flip the current BOOLEAN state

                if (noise_on) {
                    firework.volume = 1;            // reset volumes 
                    missed.volume   = 1;
                    over.volume     = 1;
                    bounce.volume   = 0.2;
                    explode.volume  = 0.4;

                } else {
                    firework.volume = 0;            // make it quiet!!!
                    missed.volume   = 0;
                    over.volume     = 0;
                    bounce.volume   = 0;
                    explode.volume  = 0;
                }
            }


            //------------------------
            function setBrickWorld() {

                // now describe the playing board
                // 0. A GAP IN THE WALL
                // 1. YELLOW    -   1 hit to EXPLODE
                // 2. GREEN     -   2 hits to EXPLODE
                // 3. GREY      -   3 hits to EXPLODE

                if (unit_test) {                                        // what are we doing here?
                     bricks = [                                         // to make the game interesting,
                            [0,0,0,0,0,0,0,0,0,0],                      // we make it winnable, but
                            [0,0,0,0,0,1,0,0,0,0]];                     // challenging.  all well and good,
                } else {                                                // unless you are testing several
                                                                        // logical branching conditions
                                                                        // in the code! To test "what happens
                                                                        // when I win can take hours using
                                                                        // real game maps!  so we inject
                                                                        // a simple little one brick
                                                                        // universe into our unit test
                                                                        // setup.  just enough to test MISS,
                                                                        // HIT and WIN.
                                                                        // what we can do using this mapping
                                                                        // construct is to introduce 'levels'
                                                                        // easily, and a user driven 'wall'
                                                                        // editor.
                    
                    
                    var chance = 0;                                                     // now we have the basics working, the
                    var weight = 0;                                                     // very
                                                                                        // first step along the way to introducing
                    for (var i = 0; i < rows_of_bricks; i++) {                          // levels is to build a random dungeon
                        bricks[i] = [];                                                 // generator.  In this first instance we
                        weight = (i*5);                                                 // choose some arbitary magic possibilities
                        for (var j = 0; j < bricks_per_row; j++) {                      // with decreasing probability as the wall
                            chance = (Math.floor(Math.random() * 100) +1);              // approaches the human.  There is no particular
                            if ((chance - weight) >= 20) {                              // reason for this approach at all, it could
                                bricks[i].push((Math.floor(Math.random() * 4)));        // just as well be evenly distributed.
                            } else {                                                    // so at the moment this algorithm is designed
                                bricks[i].push(0);                                      // to give a base chance of 80% that a cell will
                            }                                                           // be occupied. this probability decreases
                        }                                                               // as a function of the distance along the
                    }                                                                   // primary axis of the array.  ie. the world
                }                                                                       // population becomes sparser further out in
            }                                                                           // the universe.  closer to the human.



            //---------------------
            function drawPaddle() {
            
            // and draw the paddle
            // very simple in this first iteration,
            // just fill in a small rectangle.
            // this is destined to become flasher
            // once I have the game mechanics sorted out.
                
                context.fillStyle = 'black';
                context.fillRect(   paddle_x,
                                    paddle_y,
                                    (paddle_width * paddle_size),
                                    paddle_height - 8);
                context.fillStyle = 'lightslategray';
                context.fillRect(   paddle_x,
                                    paddle_y + 10,
                                    (paddle_width * paddle_size),
                                    paddle_height - 8);
            }



            //-------------------
            function drawBall() {

            // and draw the ball

                context.fillStyle = 'lightslategray';
                context.beginPath();

                // describe an arc with the centre at ball_x, ball_y
                // with a radius of ball_size for 0..2.PI radians.

                context.arc(    ball_x,
                                ball_y,
                                ball_size,
                                0,
                                Math.PI*2,
                                true);

                // and fill it, we have a plain grey ball

                context.fill();

                // now stick a light source onto it

                context.fillStyle = 'white';
                context.beginPath();

                // and make it wobble a bit

                context.arc(    ball_x-((2*(ticks % 2))+1),
                                ball_y-((2*(ticks % 2))+1),
                                ball_size/4,
                                0,
                                Math.PI*2,
                                true);

                // and fill it

                context.fill();
            }



            //-----------------------
            function createBricks() {

            // so now create the wall

                var bricks_left = 0;        // we don't much care about the N value
                                            // of this variable, just that it is
                                            // either zero or not zero.  If this
                                            // accumulator is zero after ripping
                                            // through the brick array, that means
                                            // the player has BUSTED all of the
                                            // bricks and has won!

                for (var i=0; i < bricks.length; i++) {
                    for (var j=0; j < bricks[i].length; j++) {
                        drawBrick(j,i,bricks[i][j]);
                        if (bricks[i][j]) {
                            bricks_left++;
                        }
                    }
                }
                if (bricks_left == 0) {
                    endGame(true);
                }
            }




            //------------------------------
            function drawBrick(x,y,colour) {

            // draw one brick only

                switch(colour) {
                    case 1:
                        context.fillStyle = 'yellow';
                        break;
                    case 2:
                        context.fillStyle = 'green';
                        break;
                    case 3:
                        context.fillStyle = 'grey';
                        break;
                    default:
                        // missing brick!
                        context.clearRect(  x * brick_width,
                                            y * brick_height,
                                            brick_width,
                                            brick_height);
                        break;
                }

                if (colour != 0) {
                    // fill the brick with colour and give each
                    // brick a border
                    context.fillRect(   x * brick_width,
                                        y * brick_height,
                                        brick_width,
                                        brick_height);


                    context.strokeRect( x * brick_width + 1,
                                        y * brick_height + 1,
                                        brick_width - 2,
                                        brick_height - 2);

                }
            }

            


            //-----------------------
            function displayScore() {

                // and now for a scoreboard!

                context.fillStyle = 'blue';
                context.font = "14pt MarkerFelt-Thin, Comic Sans MS";

                // clear the bottom of the canvas

                context.clearRect(  0,
                                    canvas.height - 30,
                                    canvas.width,
                                    30);

                // and write the score
                // number of lives left, and
                // time elapsed in seconds

                context.fillText(   'Score: ' + score +  
                                    '      Lives: ' + lives  + 
                                    '      Time:  ' + ticks  +
                                    '             Level:   ' + level,
                                    10,
                                    canvas.height - 5);
            }



            //-------------------
            function moveBall() {

                // now for the fun part!  We start moving them around!
                // check to see if we are hitting anything at the top

                if ((ball_y + ball_deltay - ball_size < 0) ||
                    collisionyWithBricks()) {
                    bounce.play();
                    ball_deltay = -ball_deltay;
                }

                // now the bottom

                if (ball_y + ball_deltay + ball_size >= canvas.height) {

                    missed.play();    // YOU LOSE!!
                    endGame(false);
                }

                // now check for side wall collisions

                if ((ball_x + ball_deltax - ball_size < 0) ||
                    (ball_x + ball_deltax + ball_size > canvas.width) ||
                    collisionxWithBricks()) {
                        bounce.play();
                        ball_deltax = -ball_deltax;
                } 

                // are we hitting the paddle?

                // first, are we at or heading below the paddle's
                // location in space?

                if (ball_y + ball_deltay + ball_size >= paddle_y) {
                    if (ball_x + ball_deltax >= paddle_x &&
                        ball_x + ball_deltax <= paddle_x + (paddle_width * paddle_size)) {
                            bounce.play();

                            // OK armchair physics gurus, I know the following is NOT
                            // real world physics.  However, to apply a small angular
                            // change in the angle of reflection IF the paddle is moving
                            // makes an OK representation of what happens when a ping-pong
                            // player strikes a ball.  I am not going to introduce face
                            // vector algorithms in between each ball animation just
                            // for the sake of scientific purity.   So there.


                            ball_deltay = -ball_deltay;


                            // if (paddle_move == "LEFT") {
                            //    ball_deltay = ball_deltay - Math.floor((Math.random()*2)+1);
                            // } else if (paddle_move == "RIGHT") {
                            //    ball_deltay = ball_deltay + Math.floor((Math.random()*2)+1);
                            //}
                            //
                            // that clearly did not work.  when the angle of incidence decreased,
                            // it stayed decreased throughout the universe.  I am going to have
                            // to think of a nifty way to add some randomness into this system 
                            // without altering the net energy.
                            
                    }
                }
    
                ball_x = ball_x + ball_deltax;
                ball_y = ball_y + ball_deltay; 
            }




            //-------------------------------
            function collisionxWithBricks() {

                // now the REALLY FUN BIT! Brick COLLISIONS!!

                var hit_x = false;

                for (var i=0; i < bricks.length; i++) {
                    for (var j=0; j < bricks[i].length; j++) {
                        if (bricks[i][j]) {
                        
                        // remember we assigned an integer to the COLOUR
                        // of the brick?  Well we also use this integer
                        // as a LIFE status.  An integer value of ZERO
                        // you will remember indicates a missing brick.
                        // so, if every time the brick is hit, this value
                        // is decreased, we kill the bricks!
                        //
                        // this is shown in the game as the Grey bricks
                        // are the hardest to kill with 3 lives, then
                        // green with 2 lives, then yellow with one.
                        // when hit, a grey brick will, turn green,
                        // when a greem brick  is hit it turns yellow,
                        // and when a yellow brick is hit, it goes BOOM
                        // and is no more in our universe....

                            var brick_x = j * brick_width;
                            var brick_y = i * brick_height;

                            if (((ball_x + ball_deltax + ball_size >= brick_x) &&
                                (ball_x + ball_size <= brick_x))               ||
                                (ball_x + ball_deltax - ball_size <= brick_x + brick_width) &&
                                (ball_x - ball_size >= brick_x + brick_width)) {
                                if ((ball_y + ball_deltay - ball_size <= brick_y + brick_height) &&
                                    (ball_y + ball_deltay + ball_size >= brick_y)) {
                                    bangBrick(i,j);
                                    hit_x = true;
                                }
                            }
                        }
                    }
                }
                return hit_x;
            }



            //------------------------------
            function collisionyWithBricks(){

                var hit_y = false;

                for (var i=0; i < bricks.length; i++) {
                    for (var j=0; j < bricks[i].length; j++) {
                        if (bricks[i][j]){
                            var brick_x = j * brick_width;
                            var brick_y = i * brick_height;
                            if (
                                ((ball_y + ball_deltay - ball_size <= brick_y + brick_height) && 
                                (ball_y - ball_size >= brick_y + brick_height)) ||
                                ((ball_y + ball_deltay + ball_size >= brick_y) &&
                                (ball_y + ball_size <= brick_y ))){
                                if (ball_x + ball_deltax + ball_size >= brick_x && 
                                    ball_x + ball_deltax - ball_size <= brick_x + brick_width){ 
                                    bangBrick(i,j);                          
                                    hit_y = true;
                                }                       
                            }
                        }
                    }
                }
                return hit_y;
            }
 


            //-----------------------
            function bangBrick(i,j) {
            
                // BOOM!

                bricks[i][j]-- ;            // damage or KILL the brick by removing one of
                                            // its life points
                if (bricks[i][j] > 0) {     // if the brick is still alive
                    score++ ;               // score ONE for a bounce
                } else {                    // or score 10 for a KILL and go BOOM!
                    explode.play();         // the duration of this SFX is a little long for
                    score += 10 ;           // the game.  If the previous play method hasn't
                }                           // finished, this call is ignored.  I was going
            }                               // to shorten the duration of the SFX but the
                                            // semi-random explosions actually sound quite
                                            // good.  less contrived.  so it stays.



            //---------------------
            function movePaddle() {

                // paddle goes left <-> right
                // NEVER up and down (yet)

                if (paddle_move ==  'LEFT') {
                    paddle_deltax = -paddle_speedx;
                } else if (paddle_move == 'RIGHT') {
                    paddle_deltax = paddle_speedx;
                } else {
                    paddle_deltax = 0;
                }

                // check to see if we are pressed up against the sides.
                // if so, do not let the paddle move beyond this stop point

                if (paddle_x + paddle_deltax < 0 ||
                    paddle_x + paddle_deltax + (paddle_width * paddle_size) > canvas.width) {
                        paddle_deltax = 0;
                }

                paddle_x = paddle_x + paddle_deltax;
            }




            //------------------
            function animate() {

                // this is in essence the game controller
                // it is BOUND to an interval timer and
                // is called every 20 ticks

                context.clearRect(0,0, canvas.width, canvas.height);
                                            // first clear the canvas

                createBricks();             // re-draw wall
                displayScore();             // display game information
                moveBall();                 // shift the ball in space
                movePaddle();               // PERHAPS shift the paddle in space
                drawPaddle();               // draw in new location
                drawBall();                 // draw in new location
            }
   

            //------------------------
            function resetUniverse() {

                // set game bat and ball values back to initial state

                paddle_x            = 280;                              // arbitary place to stick the paddle
                paddle_y            = 416;                              // we start the paddle off in the same
                                                                        // place every time so the player doesn't
                                                                        // have to go hunting for the thing!

                paddle_width        = 20;                               // there is a bug in these
                paddle_height       = 18;                               // numbers somewhere.  sometimes
                paddle_size         = 4;                                // the ball can rest on the underside
                                                                        // of the paddle for a moment????
                paddle_deltax       = 0;                                // pixel offsets when moving
                paddle_deltay       = 0;                                // the paddle

                paddle_move         = "NONE";                           // start still
                paddle_speedx       = 10;                               // number of pixels to move per
                                                                        // game cycle
                // now variables for the ball

                ball_x              = 300 -                             // we do allow the starting position
                                      Math.floor((Math.random()*30)+1); // of the ball to vary slightly as this
                ball_y              = 300 -                             // changes the set of possible bounce
                                      Math.floor((Math.random()*30)+1); // locations in the universe AFTER a
                                                                        // lost ball and RESTART.  Having the angle
                                                                        // of reflection equal the angle of
                                                                        // incidence can lead to a PERFECT
                                                                        // game that may be boring to play.
                                                                        // I am going to add some variability
                                                                        // in the ball -> paddle interaction
                                                                        // dynamics, whilst leaving all other
                                                                        // collissions as is.  I think that is fair
                                                                        // to the game and to 'real world'
                                                                        // physics.

                ball_size           = 10;                               // RADIUS in pixels
                ball_speed          = 1;                                // speed multiplier
                ball_deltax         = -2;                               // initial
                ball_deltay         = -4;                               // directions of the ball

                paddle_deltax       = 0;                                // paddle is not moving yet

            }



            //----------------------
            function  countTicks() {
            
                ticks++;                                                // number of seconds running

            }



            //----------------------
            function resetRuntime(){

                clearInterval(gameLoop);            // turn off the game engine, restarted in startGame
                clearInterval(tickTimer);           // unset the stopwatch
                ticks = 0;                          // elapsed time to zero
                context.lineWidth=1;                // make sure we have skinny lines
                lives = 3;                          // reset full live balance
                won = false;                        // stops endGame(won) getting confused!
                score = 0;                          // we no longer just 'drop out' of the page, reset this
                setBrickWorld();                    // reset the brick wall
            }



            //----------------------------
            function startGame(timer_on) {

                context.clearRect(0, 0, canvas.width, canvas.height);

                // set start game state, HOWEVER, not ALL variables
                // are reset as we can get in here from a LOST LIFE
                // RESTART. so we want to conserve bricks and scores.
                // the number of restart modes increases the complexity
                // of where and when these variable are initialised

                resetUniverse();

                if (! timer_on) {
                    // start a second timer 
                    tickTimer = setInterval(countTicks,1000);
                
                    // start the game by setting the interval timer
                    gameLoop = setInterval(animate,20);
                }


                context.strokeStyle = 'black';
                
                // start listening for keyboard events

                $(document).keydown(function(evt) {
                    if (evt.keyCode == 39) {
                        paddle_move = "RIGHT";                  // push  the bat right
                    } else if (evt.keyCode == 37) {
                        paddle_move = "LEFT";                   // push the bat left
                    } else if (evt.keyCode == 82) {
                        toggleNoise();                          // toggle game sounds
                    } else if (evt.keyCode == 46) {             // DEL
                        delete_scores();                        // sneaky hidden method to kill score file
                    } else if (evt.keyCode == 18) {             // ALT
                        unit_test = !unit_test;                 // sneaky hidden method to toggle unit testing
                    }
                });

                $(document).keyup(function(evt) {               // stop the bat moving
                    if (evt.keyCode == 39) {
                        paddle_move = "NONE";
                    } else if (evt.keyCode == 37) {
                        paddle_move = "NONE";
                    }
                });
            }


            //--------------
            function bye() {

                // we got here because the player won, but is bored!
                // say goodbye!
                // and give them a final clap

                context.clearRect(0,0, canvas.width, canvas.height - 50);
                context.font = "40pt MarkerFelt-Thin, Comic Sans MS";       // MarkerFelt is for the iPod
                context.lineWidth       = 3;
                context.strokeText("Come back real soon!!!!", 60, 250);
                firework.play();
                resetRuntime();
            }


            //----------------
            function croak() {

                // we got here because:
                //
                // 1.  Player ran out of lives, or,
                // 2.  Lost a life, got bored and selected QUIT
                //
                // GURGLE GURGLE GURGLE

                context.lineWidth       = 3;
                context.font = "40pt MarkerFelt-Thin, Comic Sans MS";       // MarkerFelt is for the iPod
                context.strokeText("Better Luck next time!!!", 40, 250);
                over.play();
                resetRuntime(); 
            }


            //---------------------
            function endGame(won) {

                // and shut the game down in a number of modes with a message
                // and make the message pretty

                var gradient=context.createLinearGradient(5, 50, 500, 20);

                gradient.addColorStop(0.1,  '#F82E23');
                gradient.addColorStop(0.25, '#E2E651');
                gradient.addColorStop(0.5,  '#55D268');
                gradient.addColorStop(0.75, '#5A77DA');
                gradient.addColorStop(1,    '#C84489');

                context.font = "40pt MarkerFelt-Thin, Comic Sans MS";       // MarkerFelt is for the iPod

                context.shadowOffsetX   = 5;
                context.shadowOffsetY   = 5;
                context.shadowBlur      = 10;
                context.fillStyle       = '#000000';
                context.strokeStyle     = gradient;
                context.lineWidth       = 3;

                if (won) {

                    // turn of the stopwatch, restarted in startGame
                    // we use the result of the timer to calculate
                    // the final score

                    clearInterval(tickTimer);

                    // OK, we got here if the player cleared the
                    // universe of bricks.  play them a nice applause
                    // and send them a pretty message.
                    //
                    // we can make some choices from this point:
                    //
                    // 1. Do you want to save your score=>name?
                    // 2. Do you want to play again?


                    context.strokeText("YOU WON!! HERO!!", 80, 250);
                    displayScore();                                         // resetting the context variables
                                                                            // clears the screen and loses the
                                                                            // score and timer information!
                                                                            // put it back!
                    firework.play();                                        // YAH!  WHIZZ!  BOOM! 

                                                                            // want to store your score?

                    score = (score * level) + (bonus_time - ticks);         // just a silly algorithm, but it
                                                                            // gets you on the limited leader board.
                                                                            // I limited the leader board to nine
                                                                            // entries purely for cosmentic
                                                                            // purposes.

                    if(typeof window.localStorage != 'undefined') {
                                                                            // no use asking the question if the browser can't
                                                                            // do the deed eh?
                        get_scores();                                       // get stored high scores from localStorage
                                                                            // this allows persistant data like on
                                                                            // an iPod when not connected to the net

                        var display = "Winners on this machine! \n\n";      // this ugly crap builds a leader board
                        for (var i = 0; i < scores.length; i++) {           // and a prompt to save
                            display = display + (i+1) + '.  ' + 
                                scores[i][0] + '\t'+ 
                                    scores[i][1] + '    Level   ' +
                                        scores[i][2] + '\n';
                        }
                        display = display + 
                                "\nShall we store your score?  :  " + score;


                        var winner = prompt(display,"Elmer Fudd");          // well, dywanna punk?

                        
                        if (winner != null) {                               // if NO, the string comes back empty
                                                                            // store locally
                            scores.push([winner, score, level]);            // push this score onto the stack
                            sort_scores();                                  // sort in score order
                            stringify_scores();                             // turn the array into JSON
                            delete_scores();                                // delete the old scores, they append otherwise
                            put_scores();                                   // and store the new stack [0..8] only
                        }
                    }


                                                                            // want to play again? (continue)

                    var again = confirm("Continue to next level?");
                    if (again) {
                        level++;                                            // PROMOTION!  Increases score.
                        var save_lives = lives;                             // no free lives for promotion!
                        resetRuntime();                                     // reset state variables, and
                        lives = save_lives;                                 // HA!!
                        startGame(false);                                   // HAVE FUN BUSTING BRICKS!!
                    }else {
                        bye();
                   }
                } else {

                    // OK, we got here because the player MISSED the ball and we need
                    // to subtract a life.  if lives .eq. 0, the player is dead!
                    // tell them so and croak

                    lives--;
                    if (lives == 0) {
                       croak(); 
                    } else {
                        context.lineWidth = 1;
                        var cont = confirm('You have ' + lives  + ' lives left!  Continue?');
                        if (cont) {
                            score = score - 20;             // penalty for losing a ball!
                            startGame(true);
                        } else {
                            croak();
                        }
                    }
                }
            }


            context.lineWidth =  1;         // make sure we have skinny lines for drawing
            resetUniverse();                // we need some values in this routine for
                                            // the following static drawings.
                                            // it is nice to have a still shot of the
                                            // game on the canvas, otherwise it is
                                            // cognetively confusing for the would
                                            // be player, staring at a blank white screen.
                                            // the static picure gives the required visual
                                            // cues to the brain so that when the game DOES
                                            // start, the player is accustomed to the shape of
                                            // the universe, and has plenty of clues as
                                            // to what is about to happen next.

            setBrickWorld();                // first time around, draw the bricks
            createBricks();                 // just something to look at until the GO
                                            // button is hit
            drawBall();                     // draw in or AROUND START location
            displayScore();                 // 0 0 0
            drawPaddle();                   // draw in START location STATIC
 
 
            $("#breaker_button").click(function() {
                startGame(false);
            });

        });
    </script>


<style type="text/css">


/* This is the CSS3 description of the post-it stickies
 * menu system that is driving my RETRO HTML5 movie 
 * demonstrators.  It shows a number od CSS3 techniques.
 * At the moment it does not cater for ANY IE at all.
 * That's not my object in this little experiment.
 *
 * The system is to be PURE HTML5 and CSS3 which means
 * NO Javascript
 * NO formatting in the HTML viz
 *    NO <br><hr>
 *    NO TABLES (spit)
 *    NO inlines (spit again)
 *    NO .giff, .jpeg, any graphic images to decorate.
 *
 */

body,
html {
  margin: 0;
  padding: 0;
  background:#666;
  background: -moz-linear-gradient(top,  #000,  #ccc);
  background: -webkit-linear-gradient(top, #000, #ccc);
  background: -ms-linear-gradient(top, #000, #ccc);
  background: -o-linear-gradient(top, #000, #ccc);
  background: -webkit-gradient(linear, left top, left bottom, from(#000), to(#ccc));
  background: linear-gradient(top, #000, #ccc);
  color:white;
}


#wrapper {
    width: 1100px;
    margin:0 auto;
}


#header {
    overflow: hidden;
    padding: 0px;

}


h1{
  font-family: MarkerFelt-Thin, "Comic Sans MS";
  font-size:50px;
  font-weight:normal;
  text-align:center;
  margin: 0px;
}

#content {

    float: left;
    width: 750px;
    padding: 10px;
}


#sidebar {

    float: right;
    width: 280px;
    padding:5px;
    font-family: MarkerFelt-Thin, "Comic Sans MS";
    color:blue;
    background-color:white;
    border:solid black; 
    -moz-border-radius: 5px;
    -webkit-border-radius: 5px;
    border-radius: 5px;
    -moz-box-shadow: 10px 10px 5px black;
    -webkit-box-shadow: 10px 10px 5px black;
    box-shadow: 10px 10px 5px black;
}


 #myCanvas { 
    background-color:white;
    border:solid black; 
    -webkit-border-radius: 5px;
    -moz-border-radius: 5px;
    border-radius: 5px;
    -moz-box-shadow: 10px 10px 5px black;
    -webkit-box-shadow: 10px 10px 5px black;
    box-shadow: 10px 10px 5px black;
    }

#footer {

    clear:both;
    margin:20px;
    padding:10px;
    text-align:center;
    color: black;
    font-family: MarkerFelt-Thin, "Comic Sans MS";
    font-size: 75%;
}

.red {
    color: red;
}

.blue {
    color: blue;
}

.yellow {
    color: yellow;
}

.green {
    color: green;
}

.black {
    color: black;
}


.orange {
    color: orange;
}


.button {
    border-top: 1px solid #261701;
    background: #3b3302;
    background: -webkit-gradient(linear, left top, left bottom, from(#fac60a), to(#3b3302));
    background: -webkit-linear-gradient(top, #fac60a, #3b3302);
    background: -moz-linear-gradient(top, #fac60a, #3b3302);
    background: -ms-linear-gradient(top, #fac60a, #3b3302);
    background: -o-linear-gradient(top, #fac60a, #3b3302);
    padding: 5px 10px;
    -webkit-border-radius: 10px;
    -moz-border-radius: 10px;
    border-radius: 10px;
    -webkit-box-shadow: rgba(0,0,0,1) 0 1px 0;
    -moz-box-shadow: rgba(0,0,0,1) 0 1px 0;
    box-shadow: rgba(0,0,0,1) 0 1px 0;
    text-shadow: rgba(0,0,0,.4) 0 1px 0;
    color: white;
    font-size: 17px;
    font-family: Georgia, serif;
    text-decoration: none;
    vertical-align: middle;
}


.button:hover {
    border-top-color: #5e2706;
    background: #5e2706;
    color: #ccc;
}

.button:active {
    border-top-color: #54031a;
    background: #54031a;
}



</style>

</head>



<body>
    
<audio id="bounce">
   <source src="sfx/bounce.wav">
   <source src="sfx/bounce.mp3" type='audio/mpeg; codecs="mp3"'>
</audio>

<audio id="explode">
   <source src="sfx/explode.wav">
   <source src="sfx/explode.mp3" type='audio/mpeg; codecs="mp3"'>
</audio>

<audio id="over">
   <source src="sfx/over.wav">
   <source src="sfx/over.mp3" type='audio/mpeg; codecs="mp3"'>
</audio>

<audio id="missed">
   <source src="sfx/missed.wav">
   <source src="sfx/missed.mp3" type='audio/mpeg; codecs="mp3"'>
</audio>

<audio id="firework">
   <source src="sfx/firework.wav">
   <source src="sfx/firework.mp3" type='audio/mpeg; codecs="mp3"'>
</audio>

    <div id="wrapper">
        <div id="header">
            <h1>BREAKOUT!</h1>
        </div>


        <div id="content">

            <canvas id="myCanvas" height="460" width="700">
            Your browser does not support HTML5 canvas objects.  You need a decent browser.
            </canvas>

        </div>

        <div id="sidebar">
            <p class="green"> What is BREAKOUT!?</p>
            <p class="blue"> It is part of a number of experiments that are exploring:</p>
            <ul class="black">
                <li>Cross platform development</li>
                <li class="orange">HTML5 features</li>
                <li class="green">CSS3 features</li>
                <li class="red">Modern Javascript</li>
                <li class="blue">Graphics without files</li>
                <li class="green">Animation without FLASH!</li>
                <li class="orange">Standards compliance</li>
           </ul>
           <p class="green">Instructions</p>
           <ul>
                <li>Hit the BUTTON to start!</li>
                <li class="orange">Left and Right Arrow keys to move</li>
                <li class="green">'S' or 's' toggles the noise</li>
                <li class="red">Let a Ball go to quit!</li>
           </ul>
           <p class="orange">HAVE FUN!
           <button class="button" id="breaker_button" >START!</button> 
           </p>

        </div>


        <div id="footer">
            <p>
            BREAKOUT!  by <a href="mailto:addinall@addinall.net">Mark Addinall</a> | 2013 | Brisbane Australia
            </p>
        </div>
    </div>
</body>
</html>

