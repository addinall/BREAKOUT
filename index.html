<!DOCTYPE html>
<html>
   <head>
   <meta http-equiv="content-type" content= "text/html; charset=UTF-8">
<!--  vim: set tabstop=4 shiftwidth=4 expandtab autoindent smartindent :


        index.html
        Mark Addinall
        July 2013
        Experimentation with the HTML5 canvas and audio objects
        This one is the breakout game revisited in HTML5/CSS3 and Javascript.
        SHOULD be cross platform and responsive (to an extent.  Game canvas
        really doesn't re-size well.).

        I was doing this on-line course
            https://www.udacity.com/course/viewer#!/c-cs255/l-49464373/e-73862325/m-86304040
        Dont bother, it sucks.  THEY make mistakes on EVERY example in the tutition.
        This is a result of Googling many sites including
        Aditya Ravi Shankar.
        It does a whole bunch of things differently, notably restarts from
        missed the ball.  I introduced the concept of n LIVES.
        It will also restart after a win if the player wishes.

        TODO:
        Play around with the graphics capabilities of the canvas element
        to try and get the graphics looking a little slicker.   

-->
    <title>BREAKOUT! - HTML5 experiments</title>

    <meta name="author" content="Mark Addinall Brisbane Australia">
    <meta name="keywords" content="HTML5, CSS3, Javascript, cross platform">
    <meta name="description" content="This is an implementation of the BREAKOUT game using HTML5, CSS3 and Javascript">

    <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.4.2/jquery.min.js"></script>

    <script>

        $(function() {

            var canvas = document.getElementById('myCanvas');

            // jQuery has shorthand for that, = $('#myCanvas')[0];
            // but until I REALLY want the quick and dirty shorthand,
            // we will do it the long hand way for clarity.
            // at the moment I am only using jQuery twice.  I might
            // dump it for this project just to save a little space
            // on the mobile devices.

            var context = canvas.getContext('2d');                      // this is a crap naming convention
                                                                        // and should really be changed
                                                                        // before <canvas> gets any more
                                                                        // complicated.

            var unit_test = false;                                      // switch between test mode
                                                                        // and game mode!

            // get the sound effects from the markup below
            // both WAV and MP3 versions of SFX are presented
            // to the HTML5 markup.  This will enable sounds
            // to be consistant over all of the major
            // browsers.

            var bounce      = document.getElementById('bounce');        // ball hits ANYTHING
            var explode     = document.getElementById('explode');       // brick is destroyed
            var over        = document.getElementById('over');          // game over gurgle
            var firework    = document.getElementById('firework');      // player won!  YAH!
            var missed      = document.getElementById('missed');        // ball fell down the back

            firework.volume = 1;                                        // couple of quiet SFX
            missed.volume   = 1;                                        // the range of volume is 0 .. 1
                                                                        // that was hard to find
            
            bounce.volume   = 0.2;                                      // the sample volume range of 
            explode.volume  = 0.4;                                      // the SFX i got off the net
                                                                        // varied a GREAT deal so some
                                                                        // volume munging became needed.
                                                                        // either the BOING would give you
                                                                        // a migrane and the EXPLOSION
                                                                        // made the missus drop a glass
                                                                        // of plonk, or you couldn't
                                                                        // hear the applause!!!

            // now some variable for the paddle

            var lives               = 3                                 // 3 misses, then death
            var won                 = false;                            // assume failure (NBN)
            var score               = 0;                                // 1 for hit, 10 for boom, modified
            var ticks               = 0;                                // by the time it takes to complete

            var paddle_x;                                               // arbitary place to stick the paddle
            var paddle_y;

            var paddle_width;                                           // there is a bug in these
            var paddle_height;                                          // numbers somewhere.  sometimes
            var paddle_size;                                            // the ball can rest on the underside
                                                                        // of the paddle for a moment????
            var paddle_deltax;                                          // pixel offsets when moving
            var paddle_deltay;                                          // the paddle

            var paddle_move;                                            // start still
            var paddle_speedx;                                          // number of pixels to move per
                                                                        // game cycle
            // now variables for the ball

            var ball_x;                                                 // arbitary place to stick the ball
            var ball_y;

            var ball_deltax;                                            // pixel offsets when moving
            var ball_deltay;                                            // modified by collisions

            var ball_size;                                              // RADIUS in pixels
            var ball_speed;                                             // speed multiplier

            // now for the bricks.  starting out pretty plain
            // looking, but when the game engine is working
            // we will tart them up.


            var bricks = [];                                            // empty to start.  This array
                                                                        // is filled from two locations,
                                                                        // initial play and play again

            var bricks_per_row      = 10;                               // magic numbers.  might change
            var brick_height        = 22;                               // based on difficulty level or
            var brick_width         = canvas.width/bricks_per_row;      // device type


            //------------------------
            function setBrickWorld() {

                // now describe the playing board
                // 0. A GAP IN THE WALL
                // 1. YELLOW    -   1 hit to EXPLODE
                // 2. GREEN     -   2 hits to EXPLODE
                // 3. GREY      -   3 hits to EXPLODE

                if (unit_test) {                                        // what are we doing here?
                     bricks = [                                         // to make the game interesting,
                            [0,0,0,0,1,1,1,0,0,0],                      // we make it winnable, but
                            [0,0,0,0,0,1,0,0,0,0]];                     // challenging.  all well and good,
                } else {                                                // unless you are testing several
                     bricks  = [                                        // logical branching conditions
                            [1,1,1,1,2,2,1,1,3,1],                      // in the code! To test "what happens
                            [2,2,1,1,1,2,3,3,1,1],                      // when I win can take hours using
                            [1,1,1,3,2,1,1,2,2,2],                      // real game maps!  so we inject
                            [1,2,3,0,1,2,3,0,1,2],                      // a simple little three brick
                            [0,0,0,0,0,0,0,0,0,0],                      // pyramid into our unit test
                            [0,1,0,0,3,0,3,0,0,2]                       // setup.  just enough to test MISS,
                            ];                                          // HIT and WIN.
                                                                        // what we can do using this mapping
                                                                        // construct is to introduce 'levels'
                                                                        // easily, and a user driven 'wall'
                                                                        // editor.
                }
            }



            //---------------------
            function drawPaddle() {
            
            // and draw the paddle
            // very simple in this first iteration,
            // just fill in a small rectangle.
            // this is destined to become flasher
            // once I have the game mechanics sorted out.
                
                context.fillStyle = 'black';
                context.fillRect(   paddle_x,
                                    paddle_y,
                                    (paddle_width * paddle_size),
                                    paddle_height);
            }



            //-------------------
            function drawBall() {

            // and draw the ball

                context.fillStyle = 'lightslategray';
                context.beginPath();

                // describe an arc with the centre at ball_x, ball_y
                // with a radius of ball_size for 0..2.PI radians.

                context.arc(    ball_x,
                                ball_y,
                                ball_size,
                                0,
                                Math.PI*2,
                                true);

                // and fill it, we have a plain grey ball

                context.fill();

                // now stick a light source onto it

                context.fillStyle = 'white';
                context.beginPath();

                // describe an arc with the centre at ball_x, ball_y
                // with a radius of ball_size/4 for 0..2.PI radians.

                context.arc(    ball_x-2,
                                ball_y-2,
                                ball_size/4,
                                0,
                                Math.PI*2,
                                true);

                // and fill it

                context.fill();
            }



            //-----------------------
            function createBricks() {

            // so now create the wall

                var bricks_left = 0;

                for (var i=0; i < bricks.length; i++) {
                    for (var j=0; j < bricks[i].length; j++) {
                        drawBrick(j,i,bricks[i][j]);
                        if (bricks[i][j]) {
                            bricks_left++;
                        }
                    }
                }
                if (bricks_left == 0) {
                    endGame(true);
                }
            }




            //------------------------------
            function drawBrick(x,y,colour) {

            // draw one brick only

                switch(colour) {
                    case 1:
                        context.fillStyle = 'yellow';
                        break;
                    case 2:
                        context.fillStyle = 'green';
                        break;
                    case 3:
                        context.fillStyle = 'grey';
                        break;
                    default:
                        // missing brick!
                        context.clearRect(  x * brick_width,
                                            y * brick_height,
                                            brick_width,
                                            brick_height);
                        break;
                }
                if (colour != 0) {
                    // fill the brick with colour and give each
                    // brick a border
                    context.fillRect(   x * brick_width,
                                        y * brick_height,
                                        brick_width,
                                        brick_height);


                    context.strokeRect( x * brick_width + 1,
                                        y * brick_height + 1,
                                        brick_width - 2,
                                        brick_height - 2);

                }
            }

            


            //-----------------------
            function displayScore() {

                // and now for a scoreboard!

                context.fillStyle = 'blue';
                context.font = "14pt MarkerFelt-Thin, Comic Sans MS";

                // clear the bottom of the canvas

                context.clearRect(  0,
                                    canvas.height - 30,
                                    canvas.width,
                                    30);

                // and write the score

                context.fillText(   'Score: ' + score +  '      Lives: ' + lives,
                                    10,
                                    canvas.height - 5);
            }



            //-------------------
            function moveBall() {

                // now for the fun part!  We start moving them around!
                // check to see if we are hitting anything at the top

                if ((ball_y + ball_deltay - ball_size < 0) ||
                    collisionyWithBricks()) {
                    bounce.play();
                    ball_deltay = -ball_deltay;
                }

                // now the bottom

                if (ball_y + ball_deltay + ball_size >= canvas.height) {

                    missed.play();    // YOU LOSE!!
                    endGame(false);
                }

                // now check for side wall collisions

                if ((ball_x + ball_deltax - ball_size < 0) ||
                    (ball_x + ball_deltax + ball_size > canvas.width) ||
                    collisionxWithBricks()) {
                        bounce.play();
                        ball_deltax = -ball_deltax;
                } 

                // are we hitting the paddle?

                // first, are we at or heading below the paddle's
                // location in space?

                if (ball_y + ball_deltay + ball_size >= paddle_y) {
                    if (ball_x + ball_deltax >= paddle_x &&
                        ball_x + ball_deltax <= paddle_x + (paddle_width * paddle_size)) {
                            bounce.play();
                            ball_deltay = -ball_deltay;
                    }
                }
    
                ball_x = ball_x + ball_deltax;
                ball_y = ball_y + ball_deltay; 
            }




            //-------------------------------
            function collisionxWithBricks() {

                // now the REALLY FUN BIT! Brick COLLISIONS!!

                var hit_x = false;

                for (var i=0; i < bricks.length; i++) {
                    for (var j=0; j < bricks[i].length; j++) {
                        if (bricks[i][j]) {
                        
                        // remember we assigned an integer to the COLOUR
                        // of the brick?  Well we also use this integer
                        // as a LIFE status.  An integer value of ZERO
                        // you will remember indicates a missing brick.
                        // so, if every time the brick is hit, this value
                        // is decreased, we kill the bricks!
                        //
                        // this is shown in the game as the Grey bricks
                        // are the hardest to kill with 3 lives, then
                        // green with 2 lives, then yellow with one.
                        // when hit, a grey brick will, turn green,
                        // when a greem brick  is hit it turns yellow,
                        // and when a yellow brick is hit, it goes BOOM
                        // and is no more in our universe....

                            var brick_x = j * brick_width;
                            var brick_y = i * brick_height;

                            if (((ball_x + ball_deltax + ball_size >= brick_x) &&
                                (ball_x + ball_size <= brick_x))               ||
                                (ball_x + ball_deltax - ball_size <= brick_x + brick_width) &&
                                (ball_x - ball_size >= brick_x + brick_width)) {
                                if ((ball_y + ball_deltay - ball_size <= brick_y + brick_height) &&
                                    (ball_y + ball_deltay + ball_size >= brick_y)) {
                                    bangBrick(i,j);
                                    hit_x = true;
                                }
                            }
                        }
                    }
                }
                return hit_x;
            }



            //------------------------------
            function collisionyWithBricks(){

                var hit_y = false;

                for (var i=0; i < bricks.length; i++) {
                    for (var j=0; j < bricks[i].length; j++) {
                        if (bricks[i][j]){
                            var brick_x = j * brick_width;
                            var brick_y = i * brick_height;
                            if (
                                ((ball_y + ball_deltay - ball_size <= brick_y + brick_height) && 
                                (ball_y - ball_size >= brick_y + brick_height)) ||
                                ((ball_y + ball_deltay + ball_size >= brick_y) &&
                                (ball_y + ball_size <= brick_y ))){
                                if (ball_x + ball_deltax + ball_size >= brick_x && 
                                    ball_x + ball_deltax - ball_size <= brick_x + brick_width){ 
                                    bangBrick(i,j);                          
                                    hit_y = true;
                                }                       
                            }
                        }
                    }
                }
                return hit_y;
            }
 


            //-----------------------
            function bangBrick(i,j) {
            
                // BOOM!

                bricks[i][j]-- ;            // damage or KILL the brick by removing one of
                                            // its life points
                if (bricks[i][j] > 0) {     // if the brick is still alive
                    score++ ;               // score ONE for a bounce
                } else {                    // or score 10 for a KILL and go BOOM!
                    explode.play();         // the duration of this SFX is a little long for
                    score += 10 ;           // the game.  If the previous play method hasn't
                }                           // finished, this call is ignored.  I was going
            }                               // to shorten the duration of the SFX but the
                                            // semi-random explosions actually sound quite
                                            // good.  less contrived.  so it stays.



            //---------------------
            function movePaddle() {

                // paddle goes left <-> right
                // NEVER up and down (yet)

                if (paddle_move ==  'LEFT') {
                    paddle_deltax = -paddle_speedx;
                } else if (paddle_move == 'RIGHT') {
                    paddle_deltax = paddle_speedx;
                } else {
                    paddle_deltax = 0;
                }

                // check to see if we are pressed up against the sides.
                // if so, do not let the paddle move beyond this stop point

                if (paddle_x + paddle_deltax < 0 ||
                    paddle_x + paddle_deltax + (paddle_width * paddle_size) > canvas.width) {
                        paddle_deltax = 0;
                }

                paddle_x = paddle_x + paddle_deltax;
            }




            //------------------
            function animate() {

                // this is in essence the game controller
                // it is BOUND to an interval timer and
                // is called every 20 ticks

                context.clearRect(0,0, canvas.width, canvas.height);
                                            // first clear the canvas

                createBricks();             // re-draw wall
                displayScore();             // display game information
                moveBall();                 // shift the ball in space
                movePaddle();               // PERHAPS shift the paddle in space
                drawPaddle();               // draw in new location
                drawBall();                 // draw in new location
            }
   

            //------------------------
            function resetUniverse() {

                // set game bat and ball values back to initial state

                paddle_x            = 280;                              // arbitary place to stick the paddle
                paddle_y            = 416;

                paddle_width        = 20;                               // there is a bug in these
                paddle_height       = 18;                               // numbers somewhere.  sometimes
                paddle_size         = 4;                                // the ball can rest on the underside
                // of the paddle for a moment????
                paddle_deltax       = 0;                                // pixel offsets when moving
                paddle_deltay       = 0;                                // the paddle

                paddle_move         = "NONE";                           // start still
                paddle_speedx       = 10;                               // number of pixels to move per
                                                                        // game cycle
                // now variables for the ball

                ball_x              = 300;                              // arbitary place to stick the ball
                ball_y              = 300;

                ball_size           = 10;                               // RADIUS in pixels
                ball_speed          = 1;                                // speed multiplier
                ball_deltax         = -2;
                ball_deltay         = -4;

                paddle_deltax       = 0;

            }


            //--------------------
            function startGame() {

                context.clearRect(0, 0, canvas.width, canvas.height);

                // set start game state, HOWEVER, not ALL variables
                // are reset as we can get in here from a LOST LIFE
                // RESTART. so we want to conserve bricks and scores.
                // the number of restart modes increases the complexity
                // of where and when these variable are initialised

                resetUniverse();

                // start the game by setting the interval timer

                gameLoop = setInterval(animate,20);

                context.strokeStyle = 'black';
                
                // start listening for keyboard events

                $(document).keydown(function(evt) {
                    if (evt.keyCode == 39) {
                        paddle_move = "RIGHT";
                    } else if (evt.keyCode == 37) {
                        paddle_move = "LEFT";
                    }
                });

                $(document).keyup(function(evt) {
                    if (evt.keyCode == 39) {
                        paddle_move = "NONE";
                    } else if (evt.keyCode == 37) {
                        paddle_move = "NONE";
                    }
                });
            }


            //--------------
            function bye() {

                // we got here because the player won, but is bored!
                // say goodbye!
                // and give them a final clap

                context.clearRect(0,0, canvas.width, canvas.height);
                context.lineWidth       = 3;
                context.strokeText("Come back real soon!!!!", 40, 250);
                firework.play();
                clearInterval(gameLoop);
            }


            //----------------
            function croak() {

                // we got here because:
                //
                // 1.  Player ran out of lives, or,
                // 2.  Lost a life, got bored and selected QUIT
                //
                // GURGLE GURGLE GURGLE

                context.lineWidth       = 3;
                context.strokeText("Better Luck next time!!!", 40, 250);
                over.play();
                clearInterval(gameLoop);
            }


            //---------------------
            function endGame(won) {

                // and shut the game down in a number of modes with a message
                // and make the message pretty

                var gradient=context.createLinearGradient(5, 50, 500, 20);

                gradient.addColorStop(0.1,  '#F82E23');
                gradient.addColorStop(0.25, '#E2E651');
                gradient.addColorStop(0.5,  '#55D268');
                gradient.addColorStop(0.75, '#5A77DA');
                gradient.addColorStop(1,    '#C84489');

                context.font = "40pt MarkerFelt-Thin, Comic Sans MS";       // MarkerFelt is for the iPod

                context.shadowOffsetX   = 5;
                context.shadowOffsetY   = 5;
                context.shadowBlur      = 10;
                context.fillStyle       = '#000000';
                context.strokeStyle     = gradient;
                context.lineWidth       = 3;

                if (won) {

                    // OK, we got here if the player cleared the
                    // universe of bricks.  play them a nice applause
                    // and send them a pretty message.
                    //
                    // we can make some choices from this point:
                    //
                    // 1. Do you want to save your score=>name?
                    // 2. Do you want to play again?


                    context.strokeText("YOU WON!! HERO!!", 80, 250);
                    firework.play();

                    // want to store your score?

                    var winner = prompt("Winners!\n\n1. Donald Duck\n2. Bic Lighter\n3. " +
                                        "Bugs Bunny\n4. Clint Eastwood\n5. Bella Addinall\n\n" +
                                        "Shall we store your score?  - " + score, "Game Superstar");
                    if (winner) {
                        // store locally
                    }

                    // want to play again?

                    var again = confirm("Play again?");
                    if (again) {
                        clearInterval(gameLoop);
                        context.lineWidth=1;
                        lives = 3;
                        won = false;
                        setBrickWorld(); 
                        startGame();
                    }else {
                        bye();
                   }
                } else {

                    // OK, we got here because the player MISSED the ball and we need
                    // to subtract a life.  if lives .eq. 0, the player is dead!
                    // tell them so and croak

                    lives--;
                    if (lives == 0) {
                       croak(); 
                    } else {
                        clearInterval(gameLoop);
                        context.lineWidth=1;
                        var cont = confirm('You have lives left!  Continue?');
                        if (cont) {
                            startGame();
                        } else {
                            croak();
                        }
                    }
                }
            }


            setBrickWorld();                // first time around, draw the bricks
            startGame();                    // and start the game

        });

    </script>

<link href='http://fonts.googleapis.com/css?family=Reenie+Beanie|Rock+Salt' rel='stylesheet' type='text/css'>



    <style type="text/css">


/* This is the CSS3 description of the post-it stickies
 * menu system that is driving my RETRO HTML5 movie 
 * demonstrators.  It shows a number od CSS3 techniques.
 * At the moment it does not cater for ANY IE at all.
 * That's not my object in this little experiment.
 *
 * The system is to be PURE HTML5 and CSS3 which means
 * NO Javascript
 * NO formatting in the HTML viz
 *    NO <br><hr>
 *    NO TABLES (spit)
 *    NO inlines (spit again)
 *    NO .giff, .jpeg, any graphic images to decorate.
 *
 */

body{
  font-family:arial,sans-serif;
  font-size:100%;
  background:#666;
  background: -webkit-gradient(linear, left top, left bottom, from(#000), to(#ccc));
  background: -moz-linear-gradient(top,  #000,  #ccc);
  color:#fff;
}
h1{
  font-family:"Rock Salt",arial,sans-serif;
  font-size:220%;
  font-weight:normal;
  margin:0 auto;
  text-align:center;
}

 #myCanvas { 
    background-color:white;
    border:solid black; 
    margin-left:25%;
    -moz-border-radius: 5px;
    border-radius: 5px;
    -moz-box-shadow: 10px 10px 5px black;
    -webkit-box-shadow: 10px 10px 5px black;
    box-shadow: 10px 10px 5px black;
    }

#footer p {

    text-align:center;
    color: black;
    font-family: MarkerFelt-Thin, "Comic Sans MS";
    font-size: 75%;
}


@media screen and (max-width: 650px) {

#myCanvas {

    margin: 2,2,2,2;
}

#h1 {
    text-align: left;
    font-size: 60%;
}

#footer {
    text-align: left;
}

}

</style>

</head>



<body>
    
<audio id="bounce">
   <source src="sfx/bounce.wav">
   <source src="sfx/bounce.mp3" type='audio/mpeg; codecs="mp3"'>
</audio>

<audio id="explode">
   <source src="sfx/explode.wav">
   <source src="sfx/explode.mp3" type='audio/mpeg; codecs="mp3"'>
</audio>

<audio id="over">
   <source src="sfx/over.wav">
   <source src="sfx/over.mp3" type='audio/mpeg; codecs="mp3"'>
</audio>

<audio id="missed">
   <source src="sfx/missed.wav">
   <source src="sfx/missed.mp3" type='audio/mpeg; codecs="mp3"'>
</audio>

<audio id="firework">
   <source src="sfx/firework.wav">
   <source src="sfx/firework.mp3" type='audio/mpeg; codecs="mp3"'>
</audio>


    <h1>BREAKOUT!</h1>
    <canvas id="myCanvas" height="460" width="700">
    Your browser does not support HTML5 canvas objects.  You need a decent browser.
    </canvas>
<footer id="footer">
<p>
BREAKOUT!  by Mark Addinall | 2013 | Brisbane Australia
</p>
</footer>
</body>
</html>

